##  Java byte 的 移位操作

### （byte）0xf1 = ?

```java
byte a = (byte)0xf1;
System.out.println(a)
// 输出 -15 ,过程如下：
//a1.创建一个int变量0xf1 正数 存储为原码：
0000 0000 0000 0000 0000 0000 1111 0001
//a2 强制转换为byte 直接截取底八位
1111 0001 补码（最高位为1，表明这个数是负数）
1111 0000 反码
1000 1111 原码 -15
```

### （byte） 0xf1 >> 1 = ?
```java
int x = a >> 1;
//结果 a = -8,过程如下：
//b1.将a转换为int类型（对于低于int类型的操作数，移位时总是转换为int）
1111 1111 1111 1111 1111 1111 1111 0001 补码 （补符号位）
//b2.右移1位
1111 1111 1111 1111 1111 1111 1111 1000 补码
//b3.求x值
1111 1111 1111 1111 1111 1111 1111 0111 反码
1000 0000 0000 0000 0000 0000 0000 1000 原码 （-8）
```

1.对于低于int类型的操作数，移位时总是转换为int

2.对于低于int类型的数据：a.转换为int时补符号位 b. int向下转换时直接截取低

3.其他：Integer.toBinaryString(b)和Integer.toHexString(a)输出的是计算机存储的数据（正原负补）

## (byte) 0xC1 如何通过移位获得高四位（0xC）

1，移位操作的是计算机存储的数据，也就是，正数移动的是原码，负数移动的是补码
2，（byte）0xf1是个负数。所以移动的是补码

原本想的是直接右移4位就可以了，但是结果明显出乎意料：
```java
byte a = (byte)0xa1
int b = a >> 4; 
// b = 0xffffffa （-6）,下面是过程：
// 1111 1111 1111 1111 1111 1111 1010 0001 补码 （移位时a已经转换为int了）
// 1111 1111 1111 1111 1111 1111 1111 1010 补码右移4位
// 求值
// 1111 1111 1111 1111 1111 1111 1111 1001 反码
// 1000 0000 0000 0000 0000 0000 0000 0110 原码 （-0x6）

int c = a >>> 4;
// c = 0xffffffff;（268435455）下面是过程：
// 1111 1111 1111 1111 1111 1111 1111 0001 补码 （移位时a已经转换为int了）
// 0000 1111 1111 1111 1111 1111 1111 1111 补码右移4位(无符号右移)
// 求值:上面就是一个正数，为原码，值为0xffffffa
```
**对于低于int类型的操作数，移位时总是转换为int**，所以解决方式有下面两种：

方式一:移位前转换
```java
byte a = (byte)0xa1
int b = （a&0xf0） >> 4; 
// b = 0xa;
// 1111 1111 1111 1111 1111 1111 1010 0001 a(补码)
// 0000 0000 0000 0000 0000 0000 1010 0000 a&0xf0（原码）
// 0000 0000 0000 0000 0000 0000 0000 1010 a&0xf0>>4（原码）
```
方式二：:移位后转换
```java
byte a = (byte)0xa1
int b = （a >> 4）& 0xf; 
// b = 0xa;
// 1111 1111 1111 1111 1111 1111 1010 0001 a(补码)
// 1111 1111 1111 1111 1111 1111 1111 1010 a >> 4（补码 ）
// 0000 0000 0000 0000 0000 0000 0000 1010 (a>>4)&0xf （原码）
```







