# 装饰模式 与 代理模式(委托)


##  装饰模式:

意在扩展职责.
典型应用:Android ContectWrapper

1，系统升级时可直接替换装饰对象，变更部分方法的实现方式
2，不同组件可以扩展不同的功能：`ApplicationContext` 扩展了`registerComponentCallbacks()`等行为，`Service`扩展了`onBind`等行为...

## 代理模式:

意在控制访问.
典型应用:Android ArchTaskExecutor （package com.miaxis.outdoorclock.database）

## 相同与差异:

**面向接口:**这两个设计模式看起来很像。对装饰器模式来说，装饰者（decorator）和被装饰者（decorate）都实现同一个接口。对代理模式来说，代理类（proxy class）和真实处理的类（real class）都实现同一个接口。此外，不论我们使用哪一个模式，都可以很容易地在真实对象的方法前面或者后面加上自定义的方法。

**装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。**

换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。

但是，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。    

## 选择
**当一个功能可能有一个或者多个实现时，可以考虑代理模式**
**当一个需要扩展一个类的功能时，可以考虑装饰器模式**